<?php
namespace Misago\ActiveSupport\Cache;

# Abstract cache storage.
# 
# See <tt>Misago\ActiveSupport\MemoryStore</tt>,
# <tt>Misago\ActiveSupport\MemcacheStore</tt>,
# <tt>Misago\ActiveSupport\RedisStore</tt> or
# <tt>Misago\ActiveSupport\FileStore</tt> for actual implementations.
# You may also build your own one.
# 
# Note: <tt>Misago\ActiveSupport\Cache</tt> is meant to store strings. Some
# implementations may store something else (like objects), but that shouldn't
# be used.
# 
abstract class Store extends \Misago\Object
{
  private static $singletons = array();
  
  # Transparently gets data, either already cached or to generated by the
  # closure (which is supposed to return the data).
  # 
  # For example, in your +ActionController+:
  # 
  #   class UsersController extends ApplicationController
  #   {
  #     function show()
  #     {
  #       $id   = $this->params[':id'];
  #       $user = $this->cache("cache_key", function() use($id) {
  #          return User::find($id);
  #       });
  #     }
  #   }
  # 
  function __invoke($key, $closure, $options=array())
  {
    $data = $this->read($key);
    if ($data === false)
    {
      $data = $closure();
      $this->write($key, $data, $options);
    }
    return $data;
  }
  
  # Gets a variable.
  # 
  #   $user_id = $store->read('user_id');
  #   list($user_id, $user_name) = $store->read(array('user_id', 'user_name'));
  # 
  abstract function read($key);
  
  # Sets a variable.
  # 
  #   $store->write('user_id', 123);
  #   $store->write(array('user_id' => 123, 'name' => 'John Doe'));
  # 
  # - +expires_in+ - the number of seconds this key may live in cache
  # - +expires_at+ - the date the key will expire
  # 
  abstract function write($key, $value=null, $options=array());
  
  # Sets a variable if it hasn't been set already. This is safer than checking
  # with exists and setting it afterward, since it will be executed in a single
  # and exclusive command.
  # 
  # See <tt>write()</tt> for syntax and options.
  abstract function write_once($key, $value=null, $options=array());
  
  # Deletes a variable.
  # 
  #   $store->delete('user_id');
  #   $store->delete(array('user_id', 'user_name'));
  # 
  abstract function delete($key);
  
  # Checks if a variable has been set (and hasn't expired yet).
  abstract function exists($key);
  
  # Invalidates the whole cache at once.
  abstract function clear();
  
  # Increments a variable by +$amount+.
  function increment($key, $amount=1)
  {
    if (is_array($key))
    {
      $rs = array();
      foreach($key as $k) {
        $rs[$k] = $this->increment($k, $amount);
      }
      return $rs;
    }
    $value = $this->fetch($key, 0) + $amount;
    $this->write($key, $value);
    return $value;
  }
  
  # Decrements a variable by +$amount+.
  function decrement($key, $amount=1)
  {
    if (is_array($key))
    {
      $rs = array();
      foreach($key as $k) {
        $rs[$k] = $this->decrement($k, $amount);
      }
      return $rs;
    }
    $value = max($this->fetch($key, 0) - $amount, 0);
    $this->write($key, $value);
    return $value;
  }
  
  # Gets a variable if available, otherwise returns +$default+.
  function fetch($key, $default=null)
  {
    $value = $this->read($key);
    return ($value === false) ? $default : $value;
  }
  
  static function singleton()
  {
    if (!isset(self::$singletons[get_called_class()])) {
      return self::$singletons[get_called_class()] = new static();
    }
    return self::$singletons[get_called_class()];
  }
  
  # Generates the time-to-live from +expires_in+ or +expires_at+ options.
  protected function ttl($options)
  {
    if (isset($options['expires_in']))
    {
      return is_string($options['expires_in']) ?
        strtotime($options['expires_in']) : $options['expires_in'];
    }
    elseif (isset($options['expires_at']))
    {
      return is_string($options['expires_at']) ?
        strtotime($options['expires_at']) : $options['expires_at'];
    }
    return null;
  }
}

?>
